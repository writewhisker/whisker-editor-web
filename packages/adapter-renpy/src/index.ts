/**
 * Ren'Py Format Adapter
 *
 * Provides bi-directional conversion between Whisker stories and Ren'Py format.
 * Ren'Py is a visual novel engine using Python-like syntax.
 */

import { Story, Passage, Variable } from '@writewhisker/story-models';

export interface RenpyScript {
  name: string;
  labels: RenpyLabel[];
  characters: RenpyCharacter[];
  images: RenpyImage[];
  variables: RenpyVariable[];
  metadata?: Record<string, any>;
}

export interface RenpyLabel {
  name: string;
  content: string;
  statements: RenpyStatement[];
  position?: { x: number; y: number };
}

export interface RenpyStatement {
  type: 'say' | 'menu' | 'jump' | 'call' | 'return' | 'show' | 'hide' | 'scene' | 'define' | 'python';
  speaker?: string;
  text?: string;
  target?: string;
  choices?: RenpyChoice[];
  code?: string;
}

export interface RenpyChoice {
  text: string;
  target: string;
  condition?: string;
}

export interface RenpyCharacter {
  name: string;
  displayName: string;
  color?: string;
}

export interface RenpyImage {
  name: string;
  path: string;
}

export interface RenpyVariable {
  name: string;
  value: any;
}

/**
 * Converts a Whisker Story to Ren'Py format
 */
export class RenpyExporter {
  /**
   * Export story to Ren'Py script format
   */
  public exportToRenpy(story: Story): string {
    const renpyScript = this.convertToRenpy(story);
    return this.generateRenpyScript(renpyScript);
  }

  /**
   * Convert Whisker Story to Ren'Py structure
   */
  public convertToRenpy(story: Story): RenpyScript {
    const labels = story.mapPassages(passage => this.convertPassageToLabel(passage));
    const characters = this.extractCharacters(story);
    const variables = this.extractVariables(story);

    return {
      name: story.metadata.title,
      labels,
      characters,
      images: [],
      variables,
      metadata: story.metadata,
    };
  }

  private convertPassageToLabel(passage: Passage): RenpyLabel {
    const statements = this.parseContentToStatements(passage.content);

    return {
      name: this.sanitizeLabelName(passage.title),
      content: passage.content,
      statements,
      position: passage.position,
    };
  }

  private parseContentToStatements(content: string): RenpyStatement[] {
    const statements: RenpyStatement[] = [];
    const lines = content.split('\n');
    const choices: RenpyChoice[] = [];

    for (const line of lines) {
      const trimmed = line.trim();
      if (!trimmed) continue;

      // Check for dialogue with speaker (Character: "Text")
      const dialogueMatch = trimmed.match(/^(\w+):\s*"([^"]+)"$/);
      if (dialogueMatch) {
        statements.push({
          type: 'say',
          speaker: dialogueMatch[1],
          text: dialogueMatch[2],
        });
        continue;
      }

      // Check for Whisker link syntax [[Target]] or [[Text|Target]]
      const linkMatch = trimmed.match(/\[\[([^\]|]+)(?:\|([^\]]+))?\]\]/);
      if (linkMatch) {
        // For [[Text|Target]], linkMatch[1] is the text, linkMatch[2] is the target
        // For [[Target]], linkMatch[1] is used as both text and target
        const text = linkMatch[1];
        const target = linkMatch[2] || linkMatch[1];
        choices.push({
          text,
          target: this.sanitizeLabelName(target),
        });
        continue;
      }

      // Plain text (narrator)
      if (trimmed) {
        statements.push({
          type: 'say',
          text: trimmed,
        });
      }
    }

    // Add menu if there are choices
    if (choices.length > 0) {
      statements.push({
        type: 'menu',
        choices,
      });
    }

    return statements;
  }

  private extractCharacters(story: Story): RenpyCharacter[] {
    const characters: RenpyCharacter[] = [];
    const characterSet = new Set<string>();

    // Extract characters from passage content
    for (const passage of story.passages.values()) {
      const lines = passage.content.split('\n');
      for (const line of lines) {
        const match = line.match(/^(\w+):\s*"/);
        if (match) {
          characterSet.add(match[1]);
        }
      }
    }

    // Convert to character objects
    for (const name of characterSet) {
      characters.push({
        name: name.toLowerCase(),
        displayName: name,
      });
    }

    return characters;
  }

  private extractVariables(story: Story): RenpyVariable[] {
    const variables: RenpyVariable[] = [];

    for (const [name, variable] of story.variables) {
      variables.push({ name, value: variable.initial });
    }

    return variables;
  }

  private generateRenpyScript(script: RenpyScript): string {
    const parts: string[] = [];

    // Header
    parts.push(`# ${script.name}`);
    parts.push('# Generated by Whisker Editor');
    parts.push('');

    // Character definitions
    if (script.characters.length > 0) {
      parts.push('# Characters');
      for (const char of script.characters) {
        const color = char.color ? `, color="${char.color}"` : '';
        parts.push(`define ${char.name} = Character("${char.displayName}"${color})`);
      }
      parts.push('');
    }

    // Variables
    if (script.variables.length > 0) {
      parts.push('# Variables');
      parts.push('default started = False');
      for (const variable of script.variables) {
        const value = typeof variable.value === 'string'
          ? `"${variable.value}"`
          : JSON.stringify(variable.value);
        parts.push(`default ${variable.name} = ${value}`);
      }
      parts.push('');
    }

    // Labels
    for (const label of script.labels) {
      parts.push(this.generateLabelScript(label));
      parts.push('');
    }

    return parts.join('\n');
  }

  private generateLabelScript(label: RenpyLabel): string {
    const parts: string[] = [];

    // Label header
    parts.push(`label ${label.name}:`);

    // Statements
    for (const statement of label.statements) {
      parts.push(this.generateStatement(statement, '    '));
    }

    // Default return if no other flow control
    const hasFlowControl = label.statements.some(
      s => s.type === 'jump' || s.type === 'return' || s.type === 'menu'
    );
    if (!hasFlowControl) {
      parts.push('    return');
    }

    return parts.join('\n');
  }

  private generateStatement(statement: RenpyStatement, indent: string): string {
    switch (statement.type) {
      case 'say':
        if (statement.speaker) {
          return `${indent}${statement.speaker} "${statement.text}"`;
        }
        return `${indent}"${statement.text}"`;

      case 'menu':
        const menuParts: string[] = [`${indent}menu:`];
        for (const choice of statement.choices || []) {
          menuParts.push(`${indent}    "${choice.text}":`);
          menuParts.push(`${indent}        jump ${choice.target}`);
        }
        return menuParts.join('\n');

      case 'jump':
        return `${indent}jump ${statement.target}`;

      case 'call':
        return `${indent}call ${statement.target}`;

      case 'return':
        return `${indent}return`;

      case 'show':
        return `${indent}show ${statement.text}`;

      case 'hide':
        return `${indent}hide ${statement.text}`;

      case 'scene':
        return `${indent}scene ${statement.text}`;

      case 'python':
        return `${indent}$ ${statement.code}`;

      default:
        return '';
    }
  }

  private sanitizeLabelName(name: string): string {
    // Ren'Py label names must be valid Python identifiers
    return name
      .toLowerCase()
      .replace(/[^a-z0-9_]/g, '_')
      .replace(/^(\d)/, '_$1'); // Can't start with number
  }
}

/**
 * Converts Ren'Py format to Whisker Story
 */
export class RenpyImporter {
  /**
   * Import from Ren'Py script format
   */
  public importFromRenpy(script: string): Story {
    const renpyScript = this.parseRenpyScript(script);
    return this.convertToWhisker(renpyScript);
  }

  /**
   * Parse Ren'Py script to structure
   */
  public parseRenpyScript(script: string): RenpyScript {
    const lines = script.split('\n');
    const labels: RenpyLabel[] = [];
    const characters: RenpyCharacter[] = [];
    const variables: RenpyVariable[] = [];
    let name = 'Untitled';

    let currentLabel: RenpyLabel | null = null;

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const trimmed = line.trim();

      // Skip empty lines
      if (!trimmed) continue;

      // Comments
      if (trimmed.startsWith('#')) {
        if (!name || name === 'Untitled') {
          name = trimmed.substring(1).trim();
        }
        continue;
      }

      // Character definition
      if (trimmed.startsWith('define ') && trimmed.includes('Character')) {
        const char = this.parseCharacter(trimmed);
        if (char) {
          characters.push(char);
        }
        continue;
      }

      // Variable definition
      if (trimmed.startsWith('default ')) {
        const variable = this.parseVariable(trimmed);
        if (variable) {
          variables.push(variable);
        }
        continue;
      }

      // Label
      if (trimmed.startsWith('label ')) {
        if (currentLabel) {
          labels.push(currentLabel);
        }
        const labelName = trimmed.replace(/^label\s+/, '').replace(/:$/, '').trim();
        currentLabel = {
          name: labelName,
          content: '',
          statements: [],
        };
        continue;
      }

      // Parse statements within label
      if (currentLabel) {
        const statement = this.parseStatement(line);
        if (statement) {
          currentLabel.statements.push(statement);
          // Build content representation
          if (statement.type === 'say') {
            const sayText = statement.speaker
              ? `${statement.speaker}: "${statement.text}"`
              : statement.text;
            currentLabel.content += (currentLabel.content ? '\n' : '') + sayText;
          }
        }
      }
    }

    // Add last label
    if (currentLabel) {
      labels.push(currentLabel);
    }

    return {
      name,
      labels,
      characters,
      images: [],
      variables,
    };
  }

  private parseCharacter(line: string): RenpyCharacter | null {
    // define e = Character("Eileen", color="#c8ffc8")
    const match = line.match(/define\s+(\w+)\s*=\s*Character\s*\(\s*"([^"]+)"(?:,\s*color="([^"]+)")?\)/);
    if (!match) return null;

    return {
      name: match[1],
      displayName: match[2],
      color: match[3],
    };
  }

  private parseVariable(line: string): RenpyVariable | null {
    // default score = 0
    const match = line.match(/default\s+(\w+)\s*=\s*(.+)$/);
    if (!match) return null;

    let value: any = match[2].trim();

    // Try to parse value
    try {
      value = JSON.parse(value.replace(/^"(.*)"$/, '"$1"'));
    } catch {
      // Keep as string
    }

    return {
      name: match[1],
      value,
    };
  }

  private parseStatement(line: string): RenpyStatement | null {
    const trimmed = line.trim();

    // Say statement with speaker
    const sayWithSpeaker = trimmed.match(/^(\w+)\s+"([^"]+)"$/);
    if (sayWithSpeaker) {
      return {
        type: 'say',
        speaker: sayWithSpeaker[1],
        text: sayWithSpeaker[2],
      };
    }

    // Say statement without speaker (narrator)
    const sayNarrator = trimmed.match(/^"([^"]+)"$/);
    if (sayNarrator) {
      return {
        type: 'say',
        text: sayNarrator[1],
      };
    }

    // Jump
    const jump = trimmed.match(/^jump\s+(\w+)$/);
    if (jump) {
      return {
        type: 'jump',
        target: jump[1],
      };
    }

    // Menu (simplified - would need multi-line parsing for full support)
    if (trimmed === 'menu:') {
      return {
        type: 'menu',
        choices: [],
      };
    }

    return null;
  }

  /**
   * Convert Ren'Py structure to Whisker Story
   */
  public convertToWhisker(renpyScript: RenpyScript): Story {
    const passages = renpyScript.labels.map((label, index) => this.convertLabelToPassage(label, index));

    const story = new Story({
      metadata: {
        title: renpyScript.name,
        author: '',
        version: '1.0.0',
        created: new Date().toISOString(),
        modified: new Date().toISOString(),
      },
      startPassage: passages[0]?.id || 'start',
    });

    // Clear the default passage created by Story constructor
    story.passages.clear();

    // Add passages to story
    for (const passage of passages) {
      story.passages.set(passage.id, passage);
    }

    // Update startPassage to the first actual passage
    if (passages.length > 0) {
      story.startPassage = passages[0].id;
    }

    // Store characters in settings (not part of StoryMetadata type)
    if (renpyScript.characters && renpyScript.characters.length > 0) {
      story.settings.characters = renpyScript.characters;
    }

    // Add variables
    for (const variable of renpyScript.variables) {
      const storyVar = new Variable({
        name: variable.name,
        initial: variable.value,
      });
      story.variables.set(variable.name, storyVar);
    }

    return story;
  }

  private convertLabelToPassage(label: RenpyLabel, index: number): Passage {
    let content = label.content;

    // Add menu choices as links
    const menuStatement = label.statements.find(s => s.type === 'menu');
    if (menuStatement?.choices) {
      for (const choice of menuStatement.choices) {
        content += `\n\n[[${choice.text}|${choice.target}]]`;
      }
    }

    return new Passage({
      id: label.name, // Use label name as ID for consistent referencing
      title: label.name,
      content: content.trim(),
      tags: [],
      position: label.position || {
        x: (index % 5) * 200,
        y: Math.floor(index / 5) * 200,
      },
    });
  }
}

/**
 * Main adapter class
 */
export class RenpyAdapter {
  private exporter = new RenpyExporter();
  private importer = new RenpyImporter();

  public export(story: Story): string {
    return this.exporter.exportToRenpy(story);
  }

  public import(script: string): Story {
    return this.importer.importFromRenpy(script);
  }
}
