import { describe, it, expect, beforeEach } from 'vitest';
import {
  RenpyExporter,
  RenpyImporter,
  RenpyAdapter,
  type RenpyScript,
  type RenpyLabel,
  type RenpyStatement,
} from './index';
import { Story, Passage, Variable } from '@writewhisker/story-models';

function createMockStory(): Story {
  const story = new Story({
    metadata: {
      title: 'Test Story',
    },
    startPassage: 'passage-1',
  });

  // Clear default passage and add our test passages
  story.passages.clear();

  const passage1 = new Passage({
    id: 'passage-1',
    title: 'Start',
    content: 'Narrator: "Welcome to the story!"\nAlice: "Hello!"',
    tags: [],
  });
  story.passages.set(passage1.id, passage1);

  const passage2 = new Passage({
    id: 'passage-2',
    title: 'Next Scene',
    content: 'Continue the story.\n[[Go back|Start]]',
    tags: [],
  });
  story.passages.set(passage2.id, passage2);

  story.startPassage = 'passage-1';

  // Add variables
  story.variables.set('score', new Variable({ name: 'score', initial: 0 }));
  story.variables.set('playerName', new Variable({ name: 'playerName', initial: 'Hero' }));

  return story;
}

describe('RenpyExporter', () => {
  let exporter: RenpyExporter;
  let mockStory: Story;

  beforeEach(() => {
    exporter = new RenpyExporter();
    mockStory = createMockStory();
  });

  describe('convertToRenpy', () => {
    it('should convert Whisker story to Ren\'Py structure', () => {
      const result = exporter.convertToRenpy(mockStory);

      expect(result.name).toBe('Test Story');
      expect(result.labels).toHaveLength(2);
      expect(result.characters.length).toBeGreaterThan(0);
    });

    it('should extract characters from dialogue', () => {
      const result = exporter.convertToRenpy(mockStory);

      const aliceChar = result.characters.find(c => c.displayName === 'Alice');
      expect(aliceChar).toBeDefined();
      expect(aliceChar?.name).toBe('alice');
    });

    it('should extract variables from story', () => {
      const result = exporter.convertToRenpy(mockStory);

      expect(result.variables).toHaveLength(2);
      expect(result.variables.find(v => v.name === 'score')).toBeDefined();
    });

    it('should sanitize label names', () => {
      const result = exporter.convertToRenpy(mockStory);

      expect(result.labels[0].name).toBe('start');
      expect(result.labels[1].name).toBe('next_scene');
    });

    it('should parse dialogue into statements', () => {
      const result = exporter.convertToRenpy(mockStory);

      const statements = result.labels[0].statements;
      expect(statements.some(s => s.type === 'say' && s.speaker === 'Narrator')).toBe(true);
      expect(statements.some(s => s.type === 'say' && s.speaker === 'Alice')).toBe(true);
    });
  });

  describe('exportToRenpy', () => {
    it('should generate valid Ren\'Py script', () => {
      const script = exporter.exportToRenpy(mockStory);

      expect(script).toContain('# Test Story');
      expect(script).toContain('# Generated by Whisker Editor');
      expect(script).toContain('label start:');
      expect(script).toContain('label next_scene:');
    });

    it('should include character definitions', () => {
      const script = exporter.exportToRenpy(mockStory);

      expect(script).toContain('define alice = Character("Alice")');
    });

    it('should include variable definitions', () => {
      const script = exporter.exportToRenpy(mockStory);

      expect(script).toContain('default score = 0');
      expect(script).toContain('default playerName = "Hero"');
    });

    it('should generate dialogue statements', () => {
      const script = exporter.exportToRenpy(mockStory);

      expect(script).toContain('Narrator "Welcome to the story!"');
      expect(script).toContain('Alice "Hello!"');
    });

    it('should generate menu from choices', () => {
      const storyWithChoices = new Story({
        metadata: { title: 'Test Story' },
      });
      storyWithChoices.passages.clear();
      const passage = new Passage({
        id: 'p1',
        title: 'Start',
        content: '[[Choice 1|option1]]\n[[Choice 2|option2]]',
        tags: [],
      });
      storyWithChoices.passages.set(passage.id, passage);

      const script = exporter.exportToRenpy(storyWithChoices);

      expect(script).toContain('menu:');
      // The export format uses the target name in the menu
      expect(script).toContain('jump');
    });

    it('should sanitize label names starting with numbers', () => {
      const storyWithNumbers = new Story({
        metadata: { title: 'Test Story' },
      });
      storyWithNumbers.passages.clear();
      const passage = new Passage({
        id: 'p1',
        title: '1st Scene',
        content: 'Test',
        tags: [],
      });
      storyWithNumbers.passages.set(passage.id, passage);

      const script = exporter.exportToRenpy(storyWithNumbers);

      expect(script).toContain('label _1st_scene:');
    });
  });
});

describe('RenpyImporter', () => {
  let importer: RenpyImporter;
  let mockRenpyScript: string;

  beforeEach(() => {
    importer = new RenpyImporter();
    mockRenpyScript = `# Test Story
# by Test Author

define alice = Character("Alice", color="#c8ffc8")
define bob = Character("Bob")

default score = 0
default started = False

label start:
    "Welcome to the story!"
    alice "Hello!"
    bob "Hi there!"
    jump next_scene

label next_scene:
    "This is the next scene."
    return
`;
  });

  describe('parseRenpyScript', () => {
    it('should parse Ren\'Py script to structure', () => {
      const result = importer.parseRenpyScript(mockRenpyScript);

      expect(result.name).toBe('Test Story');
      expect(result.labels).toHaveLength(2);
    });

    it('should parse character definitions', () => {
      const result = importer.parseRenpyScript(mockRenpyScript);

      expect(result.characters).toHaveLength(2);
      expect(result.characters[0].name).toBe('alice');
      expect(result.characters[0].displayName).toBe('Alice');
      expect(result.characters[0].color).toBe('#c8ffc8');
    });

    it('should parse variable definitions', () => {
      const result = importer.parseRenpyScript(mockRenpyScript);

      expect(result.variables.length).toBeGreaterThan(0);
      const scoreVar = result.variables.find(v => v.name === 'score');
      expect(scoreVar?.value).toBe(0);
    });

    it('should parse labels', () => {
      const result = importer.parseRenpyScript(mockRenpyScript);

      expect(result.labels[0].name).toBe('start');
      expect(result.labels[1].name).toBe('next_scene');
    });

    it('should parse say statements', () => {
      const result = importer.parseRenpyScript(mockRenpyScript);

      const statements = result.labels[0].statements;
      expect(statements.some(s => s.type === 'say' && s.text === 'Welcome to the story!')).toBe(true);
      expect(statements.some(s => s.type === 'say' && s.speaker === 'alice')).toBe(true);
    });

    it('should parse jump statements', () => {
      const result = importer.parseRenpyScript(mockRenpyScript);

      const jumpStmt = result.labels[0].statements.find(s => s.type === 'jump');
      expect(jumpStmt).toBeDefined();
      expect(jumpStmt?.target).toBe('next_scene');
    });

    it('should parse string variables', () => {
      const scriptWithString = `
        default name = "Alice"
        label start:
            "Test"
      `;

      const result = importer.parseRenpyScript(scriptWithString);
      const nameVar = result.variables.find(v => v.name === 'name');
      expect(nameVar?.value).toBe('Alice');
    });

    it('should build content from statements', () => {
      const result = importer.parseRenpyScript(mockRenpyScript);

      expect(result.labels[0].content).toContain('Welcome to the story!');
      expect(result.labels[0].content).toContain('alice: "Hello!"');
    });
  });

  describe('convertToWhisker', () => {
    it('should convert Ren\'Py structure to Whisker story', () => {
      const renpyScript: RenpyScript = {
        name: 'Test Story',
        labels: [
          {
            name: 'start',
            content: 'Test content',
            statements: [
              { type: 'say', text: 'Hello' },
            ],
          },
        ],
        characters: [],
        images: [],
        variables: [
          { name: 'score', value: 0 },
        ],
      };

      const result = importer.convertToWhisker(renpyScript);

      expect(result.metadata.title).toBe('Test Story');
      expect(result.startPassage).toBeDefined();
      expect(result.passages.size).toBeGreaterThanOrEqual(1);
    });

    it('should convert labels to passages', () => {
      const renpyScript: RenpyScript = {
        name: 'Test',
        labels: [
          {
            name: 'test_label',
            content: 'Label content',
            statements: [],
          },
        ],
        characters: [],
        images: [],
        variables: [],
      };

      const result = importer.convertToWhisker(renpyScript);
      const passages = Array.from(result.passages.values());
      const passage = passages.find(p => p.title === 'test_label');

      expect(passage).toBeDefined();
      expect(passage!.content).toContain('Label content');
    });

    it('should convert menu choices to Whisker links', () => {
      const renpyScript: RenpyScript = {
        name: 'Test',
        labels: [
          {
            name: 'menu_start',
            content: 'Content',
            statements: [
              {
                type: 'menu',
                choices: [
                  { text: 'Option 1', target: 'choice1' },
                  { text: 'Option 2', target: 'choice2' },
                ],
              },
            ],
          },
        ],
        characters: [],
        images: [],
        variables: [],
      };

      const result = importer.convertToWhisker(renpyScript);
      const passages = Array.from(result.passages.values());
      const passage = passages.find(p => p.title === 'menu_start');

      expect(passage).toBeDefined();
      expect(passage!.content).toContain('[[Option 1|choice1]]');
      expect(passage!.content).toContain('[[Option 2|choice2]]');
    });

    it('should preserve variables', () => {
      const renpyScript: RenpyScript = {
        name: 'Test',
        labels: [],
        characters: [
          { name: 'alice', displayName: 'Alice' },
        ],
        images: [],
        variables: [
          { name: 'score', value: 100 },
        ],
      };

      const result = importer.convertToWhisker(renpyScript);

      expect(result.variables.size).toBe(1);
      expect(result.variables.get('score')?.initial).toBe(100);
    });
  });

  describe('importFromRenpy', () => {
    it('should import complete Ren\'Py script to Whisker story', () => {
      const result = importer.importFromRenpy(mockRenpyScript);

      expect(result.metadata.title).toBe('Test Story');
      expect(result.passages.size).toBeGreaterThanOrEqual(2);
      expect(result.metadata.created).toBeDefined();
      expect(result.metadata.modified).toBeDefined();
    });
  });
});

describe('RenpyAdapter', () => {
  let adapter: RenpyAdapter;
  let mockStory: Story;

  beforeEach(() => {
    adapter = new RenpyAdapter();
    mockStory = new Story({
      metadata: { title: 'Test Story' },
      startPassage: 'p1',
    });
    mockStory.passages.clear();
    const passage = new Passage({
      id: 'p1',
      title: 'Start',
      content: 'Alice: "Hello!"\n[[Continue|next]]',
      tags: [],
    });
    mockStory.passages.set(passage.id, passage);
    mockStory.startPassage = 'p1';
  });

  describe('export', () => {
    it('should export story to Ren\'Py format', () => {
      const result = adapter.export(mockStory);

      expect(result).toContain('# Test Story');
      expect(result).toContain('label start:');
    });
  });

  describe('import', () => {
    const mockScript = `
      # Test Story
      label start:
          "Test content"
    `;

    it('should import Ren\'Py script to story', () => {
      const result = adapter.import(mockScript);

      expect(result.metadata.title).toBe('Test Story');
      expect(result.passages.size).toBeGreaterThanOrEqual(1);
    });
  });

  describe('round-trip conversion', () => {
    it('should preserve story structure through export and import', () => {
      const exported = adapter.export(mockStory);
      const imported = adapter.import(exported);

      expect(imported.metadata.title).toBe(mockStory.metadata.title);
      expect(imported.passages.size).toBeGreaterThanOrEqual(mockStory.passages.size);
    });
  });
});
